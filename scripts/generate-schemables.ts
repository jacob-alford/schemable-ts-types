import * as Cons from 'fp-ts/Console'
import { flow, pipe, tuple } from 'fp-ts/function'
import * as O from 'fp-ts/Option'
import * as RTE from 'fp-ts/ReaderTaskEither'
import * as RA from 'fp-ts/ReadonlyArray'
import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'
import * as Str from 'fp-ts/string'
import * as TE from 'fp-ts/TaskEither'
import * as ts from 'typescript'

import { CLI, cli } from './CLI'
import { FileSystem, fileSystem } from './FS'
import { run } from './run'
import { makeDestructureImport, makeModuleStarImport } from './ts-helpers'

interface Build<A> extends RTE.ReaderTaskEither<FileSystem & CLI, Error, A> {}

const _ = ts.factory

type Schemable = [name: string, path: string]

// #region Schemable

export const schemableHeaderComment: ts.JSDoc = _.createJSDocComment(
  `The extended Schemable typeclass\n\n**Warning: DO NOT EDIT, this module is autogenerated**\n\n@since 1.0.0`,
)

export const makeSchemableTypeclass: (
  schemables: ReadonlyArray<Schemable>,
) => ts.InterfaceDeclaration = schemables =>
  _.createInterfaceDeclaration(
    [_.createModifier(ts.SyntaxKind.ExportKeyword)],
    _.createIdentifier(`Schemable`),
    [
      _.createTypeParameterDeclaration(
        undefined,
        _.createIdentifier('S'),
        _.createTypeReferenceNode(_.createIdentifier('SchemableLambda')),
        undefined,
      ),
    ],
    [
      _.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
        ...pipe(
          schemables,
          RA.map(([schemable]) =>
            _.createExpressionWithTypeArguments(_.createIdentifier(schemable), [
              _.createTypeReferenceNode(_.createIdentifier('S'), undefined),
            ]),
          ),
        ),
      ]),
    ],
    [],
  )

/** Generate TS code for Schemable.ts */
const makeSchemableContents: (
  schemables: ReadonlyArray<Schemable>,
) => string = schemables => {
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed })
  const sourceFile = ts.createSourceFile(
    `${module}.ts`,
    '',
    ts.ScriptTarget.Latest,
    false,
    ts.ScriptKind.TS,
  )

  return pipe(
    [
      schemableHeaderComment,
      makeDestructureImport(['SchemableLambda'], 'schemata-ts/HKT'),
      ...pipe(
        schemables,
        RA.map(([schemable, path]) =>
          makeDestructureImport([schemable], `${path}/definition`),
        ),
      ),

      instanceComment('Schemable', '2.0.0'),
      makeSchemableTypeclass(schemables),
    ],
    _.createNodeArray,
    nodes => printer.printList(ts.ListFormat.MultiLine, nodes, sourceFile),
    Str.replace(/\/\*\*/gm, '\n/**'),
  )
}

// #endregion

type SchemableTypeclass<
  Name extends string,
  Accessor extends string,
  Version extends string,
> = [name: Name, accessor: Accessor, version: Version, fileName: string]

/** Different typeclasses which express a Schemable instance */
export type SchemableTypeclasses =
  | SchemableTypeclass<'Decoder', 'D', '2.0.0'>
  | SchemableTypeclass<'Eq', 'Eq', '2.0.0'>
  | SchemableTypeclass<'Guard', 'G', '2.0.0'>
  | SchemableTypeclass<'Encoder', 'Enc', '2.0.0'>
  | SchemableTypeclass<'Arbitrary', 'Arb', '2.0.0'>
  | SchemableTypeclass<'Printer', 'P', '2.0.0'>
  | SchemableTypeclass<'JsonSchema', 'JS', '2.0.0'>
  | SchemableTypeclass<'Schemable', '_', '2.0.0'>

// #region Typeclass modules

export const moduleHeaderComment: (module: string, version: string) => ts.JSDoc = (
  module,
  version,
) =>
  _.createJSDocComment(
    `Schemable instances for ${module}\n\n**Warning: DO NOT EDIT, this module is autogenerated**\n\n${
      module === 'Type' ? `@deprecated\n` : ''
    }@since ${version}`,
  )

export const instanceComment: (
  module: SchemableTypeclasses[0],
  version: SchemableTypeclasses[3],
) => ts.JSDoc = (__, version) =>
  _.createJSDocComment(`@since ${version}\n@category Instances`)

const makeSchemableInstance: (
  tc: SchemableTypeclasses,
  schemables: ReadonlyArray<Schemable>,
) => ts.VariableStatement = ([instanceName, accessor], schemables) =>
  _.createVariableStatement(
    [],
    _.createVariableDeclarationList(
      [
        _.createVariableDeclaration(
          _.createIdentifier(`${instanceName}Schemable`),
          undefined,
          _.createTypeReferenceNode(_.createIdentifier('Schemable'), [
            _.createTypeReferenceNode(
              _.createQualifiedName(
                _.createIdentifier(accessor),
                _.createIdentifier('SchemableLambda'),
              ),
              undefined,
            ),
          ]),
          _.createObjectLiteralExpression(
            [
              ...pipe(
                schemables,
                RA.map(([schemable]) =>
                  _.createSpreadAssignment(
                    _.createPropertyAccessExpression(
                      _.createIdentifier(schemable),
                      _.createIdentifier(instanceName),
                    ),
                  ),
                ),
              ),
            ],
            true,
          ),
        ),
      ],
      ts.NodeFlags.Const,
    ),
  )

const makeInterpreter: (typeclass: SchemableTypeclasses) => ts.VariableStatement = ([
  module,
  ,
  version,
]) =>
  ts.addSyntheticLeadingComment(
    _.createVariableStatement(
      [_.createModifier(ts.SyntaxKind.ExportKeyword)],
      _.createVariableDeclarationList(
        [
          _.createVariableDeclaration(
            _.createIdentifier(`get${module}`),
            undefined,
            undefined,
            _.createCallExpression(_.createIdentifier('interpret'), undefined, [
              _.createIdentifier(`${module}Schemable`),
            ]),
          ),
        ],
        ts.NodeFlags.Const,
      ),
    ),
    ts.SyntaxKind.MultiLineCommentTrivia,
    `* @since ${version}\n\n@category Interpreters`,
    true,
  )

/** Generate TS code for Decoder, Eq, Guard, TaskDecoder, Type, or Encoder */
const makeSchemableInstanceModuleContents: (
  typeclass: SchemableTypeclasses,
  schemables: ReadonlyArray<Schemable>,
) => string = (typeclass, schemables) => {
  const [module, accessor, sinceVersion, lowercaseModule] = typeclass

  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed })
  const sourceFile = ts.createSourceFile(
    `${module}.ts`,
    '',
    ts.ScriptTarget.Latest,
    false,
    ts.ScriptKind.TS,
  )

  return pipe(
    [
      moduleHeaderComment(module, sinceVersion),
      makeModuleStarImport(accessor, `schemata-ts/${module}`),
      makeDestructureImport(['Schemable'], 'schemata-ts/Schemable'),
      makeDestructureImport(['interpret'], 'schemata-ts/Schema'),
      ...pipe(
        schemables,
        RA.map(([schemable]) =>
          makeModuleStarImport(
            schemable,
            `schemata-ts/schemables/${schemable}/instances/${lowercaseModule}`,
          ),
        ),
      ),
      instanceComment(module, sinceVersion),
      makeSchemableInstance(typeclass, schemables),
      makeInterpreter(typeclass),
    ],
    _.createNodeArray,
    nodes => printer.printList(ts.ListFormat.MultiLine, nodes, sourceFile),
    Str.replace(/\/\*\*/gm, '\n/**'),
  )
}

const writeToDisk: (path: string) => (contents: string) => Build<void> =
  path => contents => C =>
    C.writeFile(path, contents)

// #endregion

/** Strips JSDoc comment's leading ** and trailing * */
export const extractJSDocHeaderTextFromFileContents: (
  fileContents: string,
) => string = fileContents =>
  pipe(
    fileContents,
    Str.split('*/'),
    RNEA.head,
    Str.split('/**'),
    RNEA.tail,
    RA.head,
    O.getOrElse(() => ''),
  )

/** Extracts module name, e.g. ASCII.ts -> ASCII */
const getModuleName: (file: string) => string = flow(Str.split('.'), RNEA.head)

const getSchemables: Build<ReadonlyArray<Schemable>> = C =>
  pipe(
    C.readFiles('./src/schemables'),
    TE.map(
      RA.map(fileName => {
        const schemable = getModuleName(fileName)
        return tuple(schemable, `schemata-ts/schemables/${schemable}`)
      }),
    ),
  )

const schemableTypeclasses: ReadonlyArray<SchemableTypeclasses> = [
  ['Decoder', 'D', '2.0.0', 'decoder'],
  ['Eq', 'Eq', '2.0.0', 'eq'],
  ['Guard', 'G', '2.0.0', 'guard'],
  ['Encoder', 'Enc', '2.0.0', 'encoder'],
  ['Arbitrary', 'Arb', '2.0.0', 'arbitrary'],
  ['Printer', 'P', '2.0.0', 'printer'],
  ['JsonSchema', 'JS', '2.0.0', 'json-schema'],
]

const format: Build<void> = C => C.exec('yarn format')

const main: Build<void> = pipe(
  getSchemables,
  RTE.bindTo('schemables'),
  RTE.chainFirstIOK(() => Cons.log('Writing `Schemable` instance modules...')),
  RTE.chainFirst(({ schemables }) =>
    pipe(
      schemableTypeclasses,
      RTE.traverseArray(typeclass =>
        pipe(
          makeSchemableInstanceModuleContents(typeclass, schemables),
          writeToDisk(`./src/derivations/${typeclass[0]}Schemable.ts`),
          RTE.chainFirstIOK(() => Cons.log(`  - Writing src/${typeclass[0]}.ts...`)),
        ),
      ),
    ),
  ),
  RTE.chainFirstIOK(() => Cons.log('Writing `Schemable`...')),
  RTE.chainFirst(({ schemables }) =>
    pipe(makeSchemableContents(schemables), writeToDisk(`./src/Schemable.ts`)),
  ),
  RTE.chainFirstIOK(() => Cons.log('Formatting with Prettier...')),
  RTE.chainFirst(() => format),
  RTE.chainIOK(() => Cons.log('Done!')),
)

run(
  main({
    ...fileSystem,
    ...cli,
  }),
)
