/**
 * Re- exports for all schemata-ts Schemata
 *
 * **Warning: DO NOT EDIT, this module is autogenerated**
 *
 * @since 1.0.0
 */

/** Type utilities */

export {
  /** @since 1.0.0 */
  InputOf,
  /** @since 1.0.0 */
  OutputOf,
  /** @since 1.0.0 */
  TypeOf,
} from './SchemaExt'

/** Base schemata */

export * from './base/SchemaBase'

/** Schemables */

export {
  /**
   * Schemable for constructing a branded newtype
   *
   * @since 1.0.0
   */ Schema as Brand,
} from './schemables/WithBrand/instances/schema'
export {
  /**
   * Schemable for constructing a string with a check digit (e.g. ISBN or Credit Card)
   *
   * @since 1.0.0
   */ Schema as CheckDigit,
} from './schemables/WithCheckDigit/instances/schema'
export {
  /**
   * Represents valid Date objects, and valid date-strings parsable by `Date.parse`
   *
   * @since 1.0.0
   */ Schema as Date,
} from './schemables/WithDate/instances/schema'
export {
  /**
   * Floating point branded newtype. Parameters: min, max are inclusive.
   *
   * Represents floating point numbers:
   *
   * ```math
   *  { f | f ∈ ℝ, f >= -Number.MAX_VALUE, f <= Number.MAX_VALUE }
   * ```
   *
   * @since 1.0.0
   */ Schema as Float,
} from './schemables/WithFloat/instances/schema'
export {
  /**
   * Integer branded newtype. Parameters: min, max are inclusive.
   *
   * Represents integers:
   *
   * ```math
   *  { z | z ∈ ℤ, z >= -2 ** 53 + 1, z <= 2 ** 53 - 1 }
   * ```
   *
   * @since 1.0.0
   */ Schema as Int,
} from './schemables/WithInt/instances/schema'
export {
  /**
   * Invariant mapping for schemable
   *
   * @since 1.0.0
   */ Schema as Invariant,
} from './schemables/WithInvariant/instances/schema'
export {
  /**
   * A basal schemable for Json and JsonString
   *
   * @since 1.1.0
   */ Schema as Json,
} from './schemables/WithJson/instances/schema'
export {
  /**
   * Represents a ReadonlyMap converted from an expected array of entries.
   *
   * @since 1.0.0
   */ Schema as Map,
} from './schemables/WithMap/instances/schema'
export {
  /**
   * Represents an exclusion of a supplied value where the exclusion is mapped to `None`.
   * Requires an inner schemable, and an Eq instance which defaults to strict equality.
   *
   * @since 1.0.0
   */ Schema as Option,
} from './schemables/WithOption/instances/schema'
export {
  /**
   * Schemable for widening a type to include undefined. Similar to nullable but for undefined.
   *
   * @since 1.0.0
   */ Schema as Optional,
} from './schemables/WithOptional/instances/schema'
export {
  /**
   * Adds a character to the right or left of a string until it reaches a certain length.
   *
   * @since 1.0.0
   */ Schema as Padding,
} from './schemables/WithPadding/instances/schema'
export {
  /**
   * Schemable construction based on Regex combinators
   *
   * @since 1.0.0
   */ Schema as Pattern,
} from './schemables/WithPattern/instances/schema'
export {
  /**
   * Re- export of `WithRefine` from `io-ts/Schemable/WithRefine`
   *
   * @since 1.0.0
   */ Schema as Refine,
} from './schemables/WithRefine/instances/schema'
export {
  /**
   * Re- export of `WithUnknownContainers` from `io-ts/Schemable/WithUnknownContainers`
   *
   * @since 1.0.0
   */ Schema as UnknownContainers,
} from './schemables/WithUnknownContainers/instances/schema'

/** Schemata > boolean */

export {
  /**
   * A boolean value whose encoded representation is a number, where 0 is false and 1 is true.
   *
   * Strictly speaking, this will _decode_ any number (0 becomes false, and non-zero
   * becomes true), but will only _encode_ 0 and 1.
   *
   * @since 1.0.0
   */
  BooleanFromNumber,
} from './schemata/boolean/BooleanFromNumber'
export {
  /**
   * A boolean value whose encoded representation is either "true" or "false".
   *
   * @since 1.0.0
   */
  BooleanFromString,
} from './schemata/boolean/BooleanFromString'

/** Schemata > date */

export {
  /**
   * Represents Date objects derived from time in milliseconds.
   *
   * @since 1.0.0
   */
  DateFromInt,
} from './schemata/date/DateFromInt'
export {
  /**
   * The Date parser (used in DateFromString) accepts different strings depending on
   * runtime, and also accepts other formats like `February 29, 2022`.
   *
   * `DateFromIsoString` follows a subset of the [ECMAScript 2023 Language Date Time
   * String Specification](https://tc39.es/ecma262/#sec-date-time-string-format).
   *
   * Notable features:
   *
   * - Requires `T` separator between date and time
   * - Requires padded months, days, hours, minutes, and seconds
   * - Can be configured to require a time, time and timezone offset (e.g. `Z` or `±05:00`)
   *   or neither (default is require both).
   * - Dates may contain years, months, and days; years and months; or years
   * - Times may contain hours, minutes, seconds, and milliseconds; hours, minutes, and
   *   seconds; or hours and minutes.
   * - Expanded years are permitted (e.g. `+002022` instead of `2022`)
   *
   * @since 1.0.0
   */
  DateFromIsoString,
} from './schemata/date/DateFromIsoString'
export {
  /**
   * Represents Date objects derived from unix time.
   *
   * @since 1.0.0
   */
  DateFromUnixTime,
} from './schemata/date/DateFromUnixTime'

/** Schemata > generic */

export {
  /**
   * A read-only Array containing one or more elements.
   *
   * @since 1.0.2
   */
  NonEmptyArray,
} from './schemata/generic/NonEmptyArray'
export {
  /**
   * Represents an optional type which encodes to / decodes from null
   *
   * @since 1.0.0
   */
  OptionFromNullable,
} from './schemata/generic/OptionFromNullable'
export {
  /**
   * Represents an optional type which encodes to / decodes from undefined
   *
   * @since 1.0.0
   */
  OptionFromUndefined,
} from './schemata/generic/OptionFromUndefined'

/** Schemata > json */

export {
  /**
   * Represents Json values converted from strings
   *
   * @since 1.1.0
   */
  JsonFromString,
} from './schemata/json/JsonFromString'

/** Schemata > number */

export {
  /**
   * Represents bigints converted from strings
   *
   * @since 1.0.0
   */
  BigIntFromString,
} from './schemata/number/BigIntFromString'
export {
  /**
   * Floating point branded newtype from strings. Parameters: min, max are inclusive.
   *
   * Note: doesn't technically product lawful encoder / decoders because `toString` is not
   * symmetric with `Number`.
   *
   * Represents string floating point numbers:
   *
   * ```math
   *  { f | f ∈ ℝ, f >= -Number.MAX_VALUE, f <= Number.MAX_VALUE }
   * ```
   *
   * @since 1.0.0
   */
  FloatFromString,
} from './schemata/number/FloatFromString'
export {
  /**
   * Integer branded newtype from string. Parameters: min, max are inclusive.
   *
   * Note: has an optional `encodeToBase` parameter that controls the output base of the
   * encoded string. Currently only decodes binary, octal, decimal, and hexadecimal input
   * bases. It decodes in any base, and encodes to supplied parameter defaulting to decimal.
   *
   * _Note_: Does not currently allow exponential notation (e.g. `0x123e4`).
   *
   * Represents string-integers:
   *
   * ```math
   *  { z | z ∈ ℤ, z >= -2 ** 53 + 1, z <= 2 ** 53 - 1 }
   * ```
   *
   * @since 1.0.0
   */
  IntFromString,
} from './schemata/number/IntFromString'
export {
  /**
   * Natural branded newtype.
   *
   * Represents integers:
   *
   * ```math
   *  { z | z ∈ ℤ, z >= 0, z <= 2 ** 53 - 1 }
   * ```
   *
   * @since 1.0.0
   */
  Natural,
} from './schemata/number/Natural'
export {
  /**
   * Negative floating point branded newtype.
   *
   * Represents negative floating point numbers:
   *
   * ```math
   *  { f | f ∈ ℝ, f < 0, f >= -Number.MAX_VALUE }
   * ```
   *
   * @since 1.0.0
   */
  NegativeFloat,
} from './schemata/number/NegativeFloat'
export {
  /**
   * Negative integer branded newtype.
   *
   * Represents negative integers:
   *
   * ```math
   *  { z | z ∈ ℤ, z >= -2 ** 53 + 1, z < 0 }
   * ```
   *
   * @since 1.0.0
   */
  NegativeInt,
} from './schemata/number/NegativeInt'
export {
  /**
   * Non-negative floating point branded newtype.
   *
   * Represents non-negative floating point numbers:
   *
   * ```math
   *  { f | f ∈ ℝ, f >= 0, f <= Number.MAX_VALUE }
   * ```
   *
   * @since 1.0.0
   */
  NonNegativeFloat,
} from './schemata/number/NonNegativeFloat'
export {
  /**
   * Non-positive floating point branded newtype.
   *
   * Represents non-positive floating point numbers:
   *
   * ```math
   *  { f | f ∈ ℝ, f <= 0, f >= -Number.MAX_VALUE }
   * ```
   *
   * @since 1.0.0
   */
  NonPositiveFloat,
} from './schemata/number/NonPositiveFloat'
export {
  /**
   * NonPositive integer branded newtype.
   *
   * Represents integers which are negative or zero.
   *
   * ```math
   *  { z | z ∈ ℤ, z >= -2 ** 53 + 1, z <= 0 }
   * ```
   *
   * @since 1.0.0
   */
  NonPositiveInt,
} from './schemata/number/NonPositiveInt'
export {
  /**
   * Positive Float branded newtype.
   *
   * Represents floating point numbers:
   *
   * ```math
   *  { f | f ∈ R, f > 0, f <= Number.MAX_VALUE }
   * ```
   *
   * @since 1.0.0
   */
  PositiveFloat,
} from './schemata/number/PositiveFloat'
export {
  /**
   * Positive integer branded newtype.
   *
   * Represents positive integers:
   *
   * ```math
   *  { z | z ∈ ℤ, z > 0, z <= 2 ** 53 - 1 }
   * ```
   *
   * @since 1.0.0
   */
  PositiveInt,
} from './schemata/number/PositiveInt'

/** Schemata > string */

export {
  /**
   * A string of ASCII characters.
   *
   * @since 1.0.0
   */
  Ascii,
} from './schemata/string/Ascii'
export {
  /**
   * Representing a Base64-encoded string.
   *
   * For a URL-safe version, @see Base64UrlSafe module
   *
   * @since 1.0.0
   */
  Base64,
} from './schemata/string/Base64'
export {
  /**
   * Representing a URL-safe, Base64 encoded string.
   *
   * For a non-URL-safe alternative, @see Base64
   *
   * @since 1.0.0
   */
  Base64Url,
} from './schemata/string/Base64Url'
export {
  /**
   * Represents strings which are valid Bitcoin addresses.
   *
   * @since 1.0.0
   */
  BitcoinAddress,
} from './schemata/string/BitcoinAddress'
export {
  /**
   * Represents (some) valid credit card numbers.
   *
   * At the moment, this mostly handles Visa, Mastercard, American Express, Diners Club,
   * Discover, and JCB.
   *
   * @since 1.0.0
   */
  CreditCard,
} from './schemata/string/CreditCard'
export {
  /**
   * Represents strings (email addresses) that conform to the RFC 5322 standard.
   *
   * See: https://emailregex.com/
   *
   * **Note: Does not validate international addresses**
   *
   * @since 1.0.0
   */
  EmailAddress,
} from './schemata/string/EmailAddress'
export {
  /**
   * Represents strings which are valid Ethereum addresses.
   *
   * @since 1.0.0
   */
  EthereumAddress,
} from './schemata/string/EthereumAddress'
export {
  /**
   * A string of hexadecimal characters.
   *
   * @since 1.0.0
   */
  Hexadecimal,
} from './schemata/string/Hexadecimal'
export {
  /**
   * A valid hexadecimal color value.
   *
   * @since 1.0.0
   */
  HexColor,
} from './schemata/string/HexColor'
export {
  /**
   * An HSL string. Commonly in CSS.
   *
   * @since 1.0.0
   * @example
   *   import { HslColor } from 'schemata-ts/schemata/string/HslColor'
   *   import { getGuard } from 'schemata-ts/Guard'
   *
   *   const hue = 270
   *   const saturation = 60
   *   const lightness = 70
   *   const alpha = 0.7
   *
   *   const hslString = `hsl(${hue} ${saturation}% ${lightness}% / ${alpha})`
   *   const Guard = getGuard(HslColor)
   *
   *   assert.equal(Guard.is(hslString), true)
   */
  HslColor,
} from './schemata/string/HslColor'
export {
  /**
   * A valid, Base64-encoded JWT.
   *
   * @since 1.0.0
   */
  Jwt,
} from './schemata/string/Jwt'
export {
  /**
   * Representing a Lat/Long coordinate.
   *
   * @since 1.0.0
   */
  LatLong,
} from './schemata/string/LatLong'
export {
  /**
   * A string with length greater than one
   *
   * @since 1.0.0
   */
  NonEmptyString,
} from './schemata/string/NonEmptyString'
export {
  /**
   * Represents strings which are valid RGB colors. Permits both absolute and percentage
   * based values.
   *
   * @since 1.0.0
   */
  RGB,
} from './schemata/string/RGB'
export {
  /**
   * Represents strings that are UUIDs.
   *
   * This is heavily inspired by the `validator.js` module
   * [`isUUID`](https://github.com/validatorjs/validator.js/blob/master/src/lib/isUUID.js).
   *
   * @since 1.0.0
   */
  UUID,
} from './schemata/string/UUID'
