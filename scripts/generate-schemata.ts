import * as ts from 'typescript'
import * as Cons from 'fp-ts/Console'
import { flow, pipe, tuple, unsafeCoerce } from 'fp-ts/function'
import * as E from 'fp-ts/Either'
import * as RA from 'fp-ts/ReadonlyArray'
import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'
import * as RTE from 'fp-ts/ReaderTaskEither'
import * as Str from 'fp-ts/string'
import * as TE from 'fp-ts/TaskEither'
import { FileSystem, fileSystem } from './FS'
import { cli, CLI } from './CLI'
import { run } from './run'

interface Build<A> extends RTE.ReaderTaskEither<FileSystem & CLI, Error, A> {}

const _ = ts.factory

type Schemable = [name: `With${string}`, nameWithout: string, path: string]

type Schemata = {
  readonly date: ReadonlyArray<string>
  readonly generic: ReadonlyArray<string>
  readonly number: ReadonlyArray<string>
  readonly string: ReadonlyArray<string>
}

type SchemableTypeclass<
  Name extends string,
  Accessor extends string,
  Arity extends `SchemableExt${'1' | '2' | '2C'}`,
  Version extends string,
> = [name: Name, accessor: Accessor, arity: Arity, version: Version]

/** Different typeclasses which express a Schemable instance */
export type SchemableTypeclasses =
  | SchemableTypeclass<'Decoder', 'D', 'SchemableExt2C', '1.0.0'>
  | SchemableTypeclass<'Eq', 'Eq', 'SchemableExt1', '1.0.0'>
  | SchemableTypeclass<'Guard', 'G', 'SchemableExt1', '1.0.0'>
  | SchemableTypeclass<'TaskDecoder', 'TD', 'SchemableExt2C', '1.0.0'>
  | SchemableTypeclass<'Type', 't', 'SchemableExt1', '1.0.0'>
  | SchemableTypeclass<'Encoder', 'Enc', 'SchemableExt2', '1.0.0'>
  | SchemableTypeclass<'Arbitrary', 'Arb', 'SchemableExt1', '1.0.0'>

const makeSchemableSchemaExport = ([nameWith, name]: Schemable): ts.ExportDeclaration =>
  _.createExportDeclaration(
    undefined,
    false,
    _.createNamedExports([
      _.createExportSpecifier(
        false,
        _.createIdentifier('Schema'),
        _.createIdentifier(name),
      ),
    ]),
    _.createStringLiteral(`./schemables/${nameWith}`),
    undefined,
  )

const makeSchemaExport = (category: string, name: string): ts.ExportDeclaration =>
  _.createExportDeclaration(
    undefined,
    false,
    _.createNamedExports([
      _.createExportSpecifier(false, undefined, _.createIdentifier(name)),
    ]),
    _.createStringLiteral(`./schemata/${category}/${name}`),
    undefined,
  )

const makeSchemaExportsFile: (
  schemables: ReadonlyArray<Schemable>,
  schemata: Schemata,
) => string = (schemables, schemata) => {
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed })
  const sourceFile = ts.createSourceFile(
    `${module}.ts`,
    '',
    ts.ScriptTarget.Latest,
    false,
    ts.ScriptKind.TS,
  )

  return pipe(
    [
      _.createJSDocComment(
        `Re-exports for all schemata-ts Schemata\n\n**Warning: DO NOT EDIT, this module is autogenerated**\n\n@since 1.0.0`,
      ),
      _.createJSDocComment('schemables'),
      ...pipe(schemables, RA.map(makeSchemableSchemaExport)),
      _.createJSDocComment('schemata > date'),
      ...pipe(
        schemata.date,
        RA.map(name => makeSchemaExport('date', name)),
      ),
      _.createJSDocComment('schemata > generic'),
      ...pipe(
        schemata.generic,
        RA.map(name => makeSchemaExport('generic', name)),
      ),
      _.createJSDocComment('schemata > number'),
      ...pipe(
        schemata.number,
        RA.map(name => makeSchemaExport('number', name)),
      ),
      _.createJSDocComment('schemata > string'),
      ...pipe(
        schemata.string,
        RA.map(name => makeSchemaExport('string', name)),
      ),
    ],
    _.createNodeArray,
    nodes => printer.printList(ts.ListFormat.MultiLine, nodes, sourceFile),
    Str.replace(/\/\*\*/gm, '\n/**'),
  )
}

const writeToDisk: (path: string) => (contents: string) => Build<void> =
  path => contents => C =>
    C.writeFile(path, contents)

// #endregion

/** Extracts module name, e.g. ASCII.ts -> ASCII */
const getModuleName: (file: string) => string = flow(Str.split('.'), RNEA.head)

const getSchemableName: (schmable: `With${string}`) => `With${string}` =
  unsafeCoerce(getModuleName)

const getSchemables: Build<ReadonlyArray<Schemable>> = C =>
  pipe(
    C.readFiles('./src/schemables'),
    TE.chain(
      TE.traverseArray<string, `With${string}`, Error>(
        TE.fromPredicate(
          (file): file is `With${string}` => file.length > 4 && file.startsWith('With'),
          file => E.toError(`File ${file} does not start with \`With\``),
        ),
      ),
    ),
    TE.map(
      RA.map(file => {
        const schemable = getSchemableName(file)
        return tuple(schemable, schemable.slice(4), `./schemables/${schemable}`)
      }),
    ),
  )

const getSchemata: Build<Schemata> = C =>
  pipe(
    TE.Do,
    TE.apS(
      'date',
      pipe(C.readFiles('./src/schemata/date'), TE.map(RA.map(getModuleName))),
    ),
    TE.apS(
      'generic',
      pipe(C.readFiles('./src/schemata/generic'), TE.map(RA.map(getModuleName))),
    ),
    TE.apS(
      'number',
      pipe(C.readFiles('./src/schemata/number'), TE.map(RA.map(getModuleName))),
    ),
    TE.apS(
      'string',
      pipe(C.readFiles('./src/schemata/string'), TE.map(RA.map(getModuleName))),
    ),
  )

const format: Build<void> = C => C.exec('yarn format')

const main: Build<void> = pipe(
  getSchemables,
  RTE.bindTo('schemables'),
  RTE.apS('schemata', getSchemata),
  RTE.chainFirstIOK(() => Cons.log('Writing `schemata.ts` reexports...')),
  RTE.chainFirst(({ schemables, schemata }) =>
    pipe(makeSchemaExportsFile(schemables, schemata), writeToDisk('./src/schemata.ts')),
  ),
  RTE.chainFirstIOK(() => Cons.log('Formatting with Prettier...')),
  RTE.apFirst(format),
  RTE.chainIOK(() => Cons.log('Done!')),
)

run(
  main({
    ...fileSystem,
    ...cli,
  }),
)
